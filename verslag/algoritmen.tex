\section{Algoritmen}

\input{illustraties/voorbeeld_opgave}

\subsection{Snijpunt van twee cirkels berekenen}
\label{sec:snijpunt}

\subsubsection{Algoritme}
\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{twee cirkels, $c$ en $c'$ met resp middelpunten $p_{1}, p_{2}$ en stralen $r_{1}, r_{2}$}
  \KwOut{waar als en slechts als de twee cirkels snijden}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersect($c$,$c'$)}{
    d $\leftarrow \lVert p_2 - p_1\rVert $\\
    \eIf{($d \leq r_1 + r_2) \land (d \geq abs (r_1 - r_2))$}{
      \Return{true}
    }{
      \Return{false}
    }
  }

  \caption{Nagaan of twee cirkels snijden}
\end{algorithm}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{twee cirkels, $c$ en $c'$ met resp. middelpunten $p_{1} = (x_1,y_1), p_{2} = (x_2,y_2)$ en stralen $r_{1}, r_{2}$}
  \KwOut{geen, of twee snijpunten van de twee cirkels (die dan identiek zijn)}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersections($c$,$c'$)}{
    \eIf{$intersect(c, c') \land c1 \neq c2$}{
      $d \leftarrow \lVert p_2 - p_1\rVert $ \\
      $\alpha \leftarrow \frac{r_1^2 -r_2^2}{2d^2}$\\
      $s \leftarrow \frac{x_1+x_2}{2} + \alpha(x_2-x_1)$\\
      $t \leftarrow \frac{y_1+y_2}{2} + \alpha(y_2-y_1)$\\

      $\delta \leftarrow \frac{1}{4}  \sqrt { (d+r_1+r_2)(d+r_1-r_2)(d-r_1+r_2)(r_1+r_2-d)}$\\
      $x_1' \leftarrow s + 2\delta\frac{y_1-y_2}{d^2}$\\
      $x_2' \leftarrow s - 2\delta\frac{y_1-y_2}{d^2}$\\
      $y_1' \leftarrow t - 2\delta\frac{x_1-x_2}{d^2}$\\
      $y_2' \leftarrow t + 2\delta\frac{x_1-x_2}{d^2}$\\
      \Return{$\left\{(x_1',y_1'),(x_2',y_2')\right\}$}
    }{
      \Return{$\varnothing$}
    }
  }
  \caption{Snijpunten van twee cirkels berekenen}
\end{algorithm}

\subsubsection{Theoretische Achtergrond}
\todo{aannames}
\begin{figure}[H]
\input{illustraties/snijpunten_theorie}
\end{figure}

Gegeven twee cirkels $C_1$ en $C_2$ zoeken we $C_1 \cap C_2$.


\paragraph{Mogelijke doorsneden}
\todo{Mogelijke doorsneden}

\paragraph{Benaming}
\todo{zie de figuur}
We geven de twee stralen standaard de benaming $r_1$ en $r_2$ respectievelijk.
Noem de middelpunten van de cirkels $M_1(x_1,y_1)$ en $M_2(x_2,y_2)$. 

Noem de doorsnede van $C_1$ en $C_2$ $I$. Wanneer de twee cirkels gelijk zijn geldt $C_1 = C_2 = I$.
In de rest van dit deel bespreken we enkel het geval waarbij de snijpunt(en) re\"eel zijn.
Noem de snijpunten $P_1$ en $P_2$ in de berekening.
Wanneer er maar \'e\'en snijpunt is zal de berekening nog steeds gelden, maar zal $P_1$ gelijk zijn aan $P_2$.

Het snijpunt van de rechte door $M_1$ en $M_2$ en de rechte door $P_1$ en $P_2$ noemen we $P_0$.
Noem $a$ de afstand van $P_1$ tot $P_0$ en $b$ de afstand van $P_2$ tot $P_0$.
Noem $d$ de afstand tussen $M_1$ en $M_2$.
\[
d = a + b
\]
.\todo{herschrijven, beter uitleggen}
Noem $h$ de afstand van $P_1$ (of $P_2$) tot $P_0$.

\paragraph{Snijpunten berekenen}
We zien dat de driehoeken $M_1P_1P_0$, $M_2P_1P_0$, $M_1P_2P_0$ en $M_2P_2P_0$ rechthoekige driehoeken zijn. We gebruiken nu de regel van Pythagoras om de volgende gelijkheden te bekomen.
\[
\left\{
\begin{array}{c l r}
r_1^2 = a^2 + h^2 & (1)\\
r_2^2 = b^2 + h^2 & (2)
\end{array}
\right.
\]
Trekken we vergelijking $(2)$ van vergelijking $(1)$ af, dan krijgen we volgende vergelijking.
\[
\begin{array}{r l}
r_1^2 -r_1^2 & = a^2 - b^2\\
& = (a-b)(a+b)\\
& = h(a-b)\\
& = h(a-h+a)\\
& = h(2a-h)
\end{array}
\]
\[
a = \frac{r_1^2-r_2^2 + h^2}{2h}
\]
\[
m = \frac{y_2-y_1}{x_2-x_1} \rightarrow n = -\frac{1}{m}
\]
\[
P_0 = M_1 + a(M_2-M_1)
\]
\[
\left\{
\begin{array}{c l}
P_x &= x_0 \pm \frac{h}{d}(y_2-y_1)\\
P_y &= y_0 \mp \frac{h}{d}(x_2-x_1)
\end{array}
\right.
\]




\subsubsection{Complexiteit}
\todo{constant... duh}

\subsection{Na\"ief}
\label{sec:naief}

\subsubsection{Algoritme}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{een lijst van $n$ cirkels $C$, gegeven door hun middelpunt en straal}
  \KwOut{een verzameling van $S$ snijpunten $R$ van de cirkels in $C$}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersections1($C$)}{
    R $\leftarrow \varnothing$\;
    \For{$i\leftarrow 1$ \KwTo $n$}{
      \For{$j\leftarrow i$ \KwTo $n$}{
        $R \leftarrow R \cup intersections(C(i),C(j))$
      }

    }
    \Return{R}
  }
  \caption{Na\"ieve aanpak (imperatief)}
  \label{algo:naive}
\end{algorithm}

\subsubsection{Correctheidsbewijs}
\begin{stl} Algoritme \ref{algo:naive} is correct en eindig.\end{stl}
\begin{proof}
Het algoritme eindigt: immers, de instructie in de binnenste for-lus
wordt exact \[\sum_{i=1}^{n} \sum_{j<i}^{n} 1 = \frac{n(n-1)}{2} \]
keer uitgevoerd. 

De correctheid van het algoritme bewijzen we met een lusinvariante:
\begin{inv} 
Na de $i^{\textrm{de}}$ iteratie van de buitenste lus zijn
alle snijpunten van de eerste $i$ cirkels met de andere cirkels
toegevoegd aan de verzameling snijpunten.
\end{inv} 

We bewijzen dit per inductie.

\textit{Basisstap.} Het is duidelijk dat voor $i = 1$ de invariante
geldt. Immers, na iteratie 1 hebben we cirkel 1 in de lijst nagekeken
op snijpunten met alle $n-1$ andere cirkels, en zijn dus alle
snijpunten van de eerste $i$ cirkels met alle andere cirkels
toegevoegd aan de verzameling snijpunten.

\textit{Inductiestap.} Stel dat voor de eerste $i - 1$ iteraties de
invariante geldt. We tonen aan dat na de $i^{\textrm{de}}$
iteratie de invariante nog geldt. In de $i^{\textrm{de}}$ iteratie
wordt cirkel $i$ nagekeken op snijpunten met alle cirkels die later in
de lijst komen. De snijpunten van $i$ met alle cirkels die later in de
lijst komen zullen dus zeker in de verzameling snijpunten zitten na
afloop van deze iteratie. 

Maar ook alle snijpunten met de cirkels die vroeger in de lijst zitten
hebben we al gevonden en bijgehouden; immers, in \'e\'en van de vorige
iteraties is het snijpunt van elk van die cirkels met cirkel $i$ al
berekend en toegevoegd aan de verzameling snijpunten. Bij krachte van
het inductieprincipe bevat de verzameling snijpunten na iteratie $i$
dus alle snijpunten van de eerste $i$ cirkels met alle andere
cirkels. Na iteratie $n$ zijn dus alle snijpunten gevonden; het
algoritme is correct.
\end{proof}

\subsubsection{Complexiteit}
De na\"ieve aanpak heeft complexiteit $O(n^2)$. Dit volgt rechtstreeks uit ons bewijs van eindigheid.

% \begin{figure}
%   \[
%   intersections\ cs\ = \{\ circleIntersections\ c1\ c2\ |\ c1 \leftarrow\ cs,\ c2\ \leftarrow\\ cs \}
%   \]
%   \label{naief_functioneel}
%   \caption{Na\"ieve aanpak (functioneel)}
% \end{figure}

\input{illustraties/voorbeeld_1}

\subsection{Kwadratisch}
\label{sec:kwadratisch}

\subsubsection{Algoritme}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{een lijst van $n$ cirkels $C$, gegeven door hun middelpunt en straal}
  \KwOut{een verzameling van $S$ snijpunten $R$ van de cirkels in $C$}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersections2($C$)}{
    $E \leftarrow \varnothing$\;
    \For{$c \in C$}{
      $E \leftarrow E \cup events(c)$;
    }
    $E \leftarrow sort(E)$\;
    $T, R \leftarrow \varnothing$\;
    \For{$e \in E$}{
      \uIf {e == insert c} {
        \For{$c' \in T$} {
          $R \leftarrow R \cup intersections(c,c')$
        }
        $T \leftarrow T \cup \left\{c\right\}$
      } \ElseIf {e == delete c} {
        $T \leftarrow T \setminus \left\{c\right\} $
      }
    }
    \Return{R}
  }
  \caption{Kwadratische aanpak (imperatief)}
  \label{algo:quadratic}
\end{algorithm}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{een cirkel $c$ met middelpunt $(x, y)$ en straal $r$}
  \KwOut{twee \textit{events} $e_1$ en $e_2$,
    corresponderend aan het toevoegen en verwijderen van $c$ aan de
    doorlooplijn, waarbij elk event ook de $y$-co\"ordinaat waarop
    het gebeurt met zich meedraagt}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{events($c$)}{
    $y_1 \leftarrow  y - r$\;
    $y_2 \leftarrow  y + r$\;
    $R \leftarrow \left\{(y_1, insert\ c), (y_2, delete\ c)\right\}$\;
    \Return{R}
  }
  \caption{Events}
  \label{algo:events}
\end{algorithm}

% \begin{figure}
%   \[
%   intersections\ cs = go\ (sort\ (events\ cs))\ [\ ]
%   \]
%   \[
%   where 
%   \]
%   \[
%   \begin{array}{l c l}
%     go\ [\ ] &= &[\ ]\\
%     go (Insert\ c\ :\ es) T &= &(map\ (circleIntersections\ c)\ T) \cup (go\ es\ T\cup\{c\})\\
%     go (Delete\ c\ :\ es) T &= &go\ es\ T\backslash\{c\}\\
%   \end{array}
%   \]
%   \label{naief_functioneel}
%   \caption{Kwadratische aanpak (functioneel)}
% \end{figure}
\subsubsection{Correctheidsbewijs}
\begin{stl} Algoritme \ref{algo:quadratic} is correct en eindig.\end{stl}
\begin{proof}
We bewijzen eerst dat het algoritme eindigt, dan dat het correct
is. 

De eerste for-lus is eindig en levert een eindige verzameling van
events $E$ op; dit volgt rechtstreeks uit de eindigheid van de
verzameling cirkels $C$ en uit het feit dat algoritme
\ref{algo:events} altijd een eindige verzameling teruggeeft. De tweede
for-lus is genest; we bewijzen dat ook deze eindigt.

De binnenste for-lus past de binnenste lus van het na\"ieve algoritme
dat we in de vorige sectie besproken hebben toe op $T$, en is dus
gegarandeerd eindig als de verzameling $T$ bij elke iteratie eindig
is. Om dat aan te tonen, bewijzen we eerst dat de buitenste for-lus
eindig is.  Die behandelt elk element in $E$ \'e\'enmaal; het aantal
iteraties ligt dus vast op $\abs{E}$ en de lus eindigt.

Nu kunnen we aantonen dat $T$ altijd eindig is. We doen dit wederom
met een invariante.

\begin{inv}
$T$ bevat na elke iteratie van de buitenste lus maximaal $n$ elementen.
\end{inv}

Op het einde van elke iteratie van de buitenste lus wordt exact
\'e\'en cirkel ofwel toegevoegd aan ofwel verwijderd uit $T$. Elke
cirkel wordt exact \'e\'en keer toegevoegd aan of verwijderd uit $T$
(zie algoritme \ref{algo:events}). Dus $E$ bevat exact $2n$
elementen. Stel nu dat $T$ na iteratie $i$ $n + 1$ elementen zou
bevatten. Er zijn maar $n$ cirkels, dus volgens het duiventilprincipe
zou er ergens een cirkel tweemaal moeten toegevoegd zijn, wat in
strijd is met het feit dat elke cirkel exact \'e\'en keer
toegevoegd aan of verwijderd uit $T$. Dit kan niet en dus moet $T$
maximaal $n$ elementen bevatten. Hiermee is de eindigheid van het
algoritme bewezen.

Nu gaan we over tot een correctheidsbewijs. In de binnenste lus wordt
een cirkel ofwel toegevoegd ofwel verwijderd uit $T$, en voor deze
twee gevallen stellen we volgende twee invarianten op:

\begin{inv}
Elk element dat niet in $T$ zit v\'o\'or iteratie $i$ kan onmogelijk
snijden met een cirkel die toegevoegd wordt tijdens iteratie $i$.
\end{inv}

\begin{inv}
Elk element dat uit $T$ verwijderd wordt tijdens iteratie $i$ kan onmogelijk
snijden met een cirkel die toegevoegd wordt tijdens iteratie $j > i$.
\end{inv}

\end{proof}
\subsubsection{Complexiteit}

\input{illustraties/voorbeeld_2}

\subsection{Linearitmisch}
\label{sec:linearitmisch}

\subsubsection{Algoritme}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{een cirkel $c$ met middelpunt $(x, y)$ en straal $r$}
  \KwOut{een interval $I$ corresponderend aan het interval tussen de uiterste $x$-co\"ordinaten van $c$}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{interval($c$)}{
    $x_1 \leftarrow x - r$\;
    $x_2 \leftarrow x + r$\;
    $I \leftarrow [x_1, x_2]$\;
    \Return{I}
  }
  \caption{Breedte-interval van een cirkel}
\end{algorithm}
\label{algo:interval}

\begin{algorithm}[H]
  \KwIn{een lijst van $n$ cirkels $C$, gegeven door hun middelpunt en straal}
  \KwOut{een verzameling van $S$ snijpunten $R$ van de cirkels in $C$}
  \SetAlgoLined
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersections3($C$)}{
    $E \leftarrow \varnothing$\;
    \For{$c \in C$}{
      $E \leftarrow E \cup events(c)$;
    }
    $E \leftarrow sort(E)$\;
    $T, R \leftarrow \varnothing$\;
    \For{$e \in E$}{
      \uIf {e == insert c} {
        \For{$c' \in T$} {
          \If {$interval(c) \cap interval(c') \neq \varnothing$} {
            $R \leftarrow R \cup intersections(c,c')$
          }
        }
        $T \leftarrow T \cup \left\{c\right\}$
      } \ElseIf {e == delete c} {
        $T \leftarrow T \setminus \left\{c\right\} $
      }
    }
    \Return{R}
  }
  \caption{Linearitmische aanpak (imperatief)}
\end{algorithm}
\subsubsection{Correctheidsbewijs}
\subsubsection{Complexiteit}

\input{illustraties/voorbeeld_3}