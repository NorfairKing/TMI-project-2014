\section{Algoritmen}

\input{illustraties/voorbeeld_opgave}

\subsection{De snijpunten van twee cirkels berekenen}
\label{sec:snijpunt}

\subsubsection{Algoritme}
\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{twee cirkels, $c$ en $c'$ met resp middelpunten $p_{1}, p_{2}$ en stralen $r_{1}, r_{2}$}
  \KwOut{waar als en slechts als de twee cirkels snijden}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersect($c$,$c'$)}{
    d $\leftarrow \lVert p_2 - p_1\rVert $\\
    \eIf{($d \leq r_1 + r_2) \land (d \geq abs (r_1 - r_2))$}{
      \Return{true}
    }{
      \Return{false}
    }
  }

  \caption{Nagaan of twee cirkels snijden}
\end{algorithm}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{twee cirkels, $c$ en $c'$ met resp. middelpunten $p_{1} = (x_1,y_1), p_{2} = (x_2,y_2)$ en stralen $r_{1}, r_{2}$}
  \KwOut{geen, of twee snijpunten van de twee cirkels (\'e\'en punt met multipliciteit twee of twee met multipliciteit \'e\'en)}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersections($c$,$c'$)}{
    \eIf{$intersect(c, c') \land c1 \neq c2$}{
      $d \leftarrow \lVert p_2 - p_1\rVert $ \\
      $\alpha \leftarrow \frac{r_1^2 -r_2^2}{2d^2}$\\
      $s \leftarrow \frac{x_1+x_2}{2} + \alpha(x_2-x_1)$\\
      $t \leftarrow \frac{y_1+y_2}{2} + \alpha(y_2-y_1)$\\

      $\delta \leftarrow \frac{1}{4}  \sqrt { (d+r_1+r_2)(d+r_1-r_2)(d-r_1+r_2)(r_1+r_2-d)}$\\
      $x_1' \leftarrow s + 2\delta\frac{y_1-y_2}{d^2}$\\
      $x_2' \leftarrow s - 2\delta\frac{y_1-y_2}{d^2}$\\
      $y_1' \leftarrow t - 2\delta\frac{x_1-x_2}{d^2}$\\
      $y_2' \leftarrow t + 2\delta\frac{x_1-x_2}{d^2}$\\
      \Return{$\left\{(x_1',y_1'),(x_2',y_2')\right\}$}
    }{
      \Return{$\varnothing$}
    }
  }
  \caption{Snijpunten van twee cirkels berekenen}
\end{algorithm}

\subsubsection{Theoretische achtergrond}
\todo{aannames}
\begin{figure}[H]
\input{illustraties/snijpunten_theorie}
\end{figure}

Gegeven twee cirkels $C_1$ en $C_2$ zoeken we $C_1 \cap C_2$.


\paragraph{Mogelijke doorsneden}
\todo{Mogelijke doorsneden}

\paragraph{Benaming}
\todo{zie de figuur}
We geven de twee stralen standaard de benaming $r_1$ en $r_2$ respectievelijk.
Noem de middelpunten van de cirkels $M_1(x_1,y_1)$ en $M_2(x_2,y_2)$. 

Noem de doorsnede van $C_1$ en $C_2$ $I$. Wanneer de twee cirkels gelijk zijn geldt $C_1 = C_2 = I$.
In de rest van dit deel bespreken we enkel het geval waarbij de snijpunt(en) re\"eel zijn.
Noem de snijpunten $P_1$ en $P_2$ in de berekening.
Wanneer er maar \'e\'en snijpunt is zal de berekening nog steeds gelden, maar zal $P_1$ gelijk zijn aan $P_2$.

Het snijpunt van de rechte door $M_1$ en $M_2$ en de rechte door $P_1$ en $P_2$ noemen we $P_0$.
Noem $a$ de afstand van $P_1$ tot $P_0$ en $b$ de afstand van $P_2$ tot $P_0$.
Noem $d$ de afstand tussen $M_1$ en $M_2$.
\[
d = a + b
\]
.\todo{herschrijven, beter uitleggen}
Noem $h$ de afstand van $P_1$ (of $P_2$) tot $P_0$.

\paragraph{Snijpunten berekenen}
We zien dat de driehoeken $M_1P_1P_0$, $M_2P_1P_0$, $M_1P_2P_0$ en $M_2P_2P_0$ rechthoekige driehoeken zijn. We gebruiken nu de regel van Pythagoras om de volgende gelijkheden te bekomen.
\[
\left\{
\begin{array}{c l r}
r_1^2 = a^2 + h^2 & (1)\\
r_2^2 = b^2 + h^2 & (2)
\end{array}
\right.
\]
Trekken we vergelijking $(2)$ van vergelijking $(1)$ af, dan krijgen we volgende vergelijking.
\[
\begin{array}{r l}
r_1^2 -r_1^2 & = a^2 - b^2\\
& = (a-b)(a+b)\\
& = h(a-b)\\
& = h(a-h+a)\\
& = h(2a-h)
\end{array}
\]
\[
a = \frac{r_1^2-r_2^2 + h^2}{2h}
\]
\[
m = \frac{y_2-y_1}{x_2-x_1} \rightarrow n = -\frac{1}{m}
\]
\[
P_0 = M_1 + a(M_2-M_1)
\]
\[
\left\{
\begin{array}{c l}
P_x &= x_0 \pm \frac{h}{d}(y_2-y_1)\\
P_y &= y_0 \mp \frac{h}{d}(x_2-x_1)
\end{array}
\right.
\]




\subsubsection{Complexiteit}
\todo{constant... duh}

\subsection{Na\"ief}
\label{sec:naief}

\subsubsection{Algoritme}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{een lijst van $n$ cirkels $C$, gegeven door hun middelpunt en straal}
  \KwOut{een verzameling van $S$ snijpunten $R$ van de cirkels in $C$}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersections1($C$)}{
    R $\leftarrow \varnothing$\;
    \For{$i\leftarrow 1$ \KwTo $n$}{
      \For{$j\leftarrow i$ \KwTo $n$}{
        $R \leftarrow R \cup intersections(C(i),C(j))$
      }

    }
    \Return{R}
  }
  \caption{Na\"ieve aanpak (imperatief)}
  \label{algo:naive}
\end{algorithm}

\subsubsection{Correctheidsbewijs}
\begin{stl} Algoritme \ref{algo:naive} is correct en eindig.\end{stl}
\begin{proof}
Het algoritme eindigt: immers, de instructie in de binnenste for-lus
wordt exact \[\sum_{i=1}^{n} \sum_{j<i}^{n} 1 = \frac{n(n-1)}{2} \]
keer uitgevoerd. 

De correctheid van het algoritme bewijzen we met een lusinvariante:
\begin{inv} 
Na de $i^{\textrm{de}}$ iteratie van de buitenste lus zijn
alle snijpunten van de eerste $i$ cirkels met de andere cirkels
toegevoegd aan de verzameling snijpunten.
\end{inv} 

We bewijzen dit per inductie.

\textit{Basisstap.} Het is duidelijk dat voor $i = 1$ de invariante
geldt. Immers, na iteratie 1 hebben we cirkel 1 in de lijst nagekeken
op snijpunten met alle $n-1$ andere cirkels, en zijn dus alle
snijpunten van de eerste $i$ cirkels met alle andere cirkels
toegevoegd aan de verzameling snijpunten.

\textit{Inductiestap.} Stel dat voor de eerste $i - 1$ iteraties de
invariante geldt. We tonen aan dat na de $i^{\textrm{de}}$
iteratie de invariante nog geldt. In de $i^{\textrm{de}}$ iteratie
wordt cirkel $i$ nagekeken op snijpunten met alle cirkels die later in
de lijst komen. De snijpunten van $i$ met alle cirkels die later in de
lijst komen zullen dus zeker in de verzameling snijpunten zitten na
afloop van deze iteratie. 

Maar ook alle snijpunten met de cirkels die vroeger in de lijst zitten
hebben we al gevonden en bijgehouden; immers, in \'e\'en van de vorige
iteraties is het snijpunt van elk van die cirkels met cirkel $i$ al
berekend en toegevoegd aan de verzameling snijpunten. Bij krachte van
het inductieprincipe bevat de verzameling snijpunten na iteratie $i$
dus alle snijpunten van de eerste $i$ cirkels met alle andere
cirkels. Na iteratie $n$ zijn dus alle snijpunten gevonden; het
algoritme is correct.
\end{proof}

\subsubsection{Complexiteit}
De na\"ieve aanpak heeft complexiteit $O(n^2)$. Dit volgt rechtstreeks uit ons bewijs van eindigheid.

% \begin{figure}
%   \[
%   intersections\ cs\ = \{\ circleIntersections\ c1\ c2\ |\ c1 \leftarrow\ cs,\ c2\ \leftarrow\\ cs \}
%   \]
%   \label{naief_functioneel}
%   \caption{Na\"ieve aanpak (functioneel)}
% \end{figure}

\input{illustraties/voorbeeld_1}

\subsection{Kwadratisch}
\label{sec:kwadratisch}

\subsubsection{Algoritme}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{een lijst van $n$ cirkels $C$, gegeven door hun middelpunt en straal}
  \KwOut{een verzameling van $S$ snijpunten $R$ van de cirkels in $C$}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersections2($C$)}{
    $E \leftarrow \varnothing$\;
    \For{$c \in C$}{
      $E \leftarrow E \cup events(c)$;
    }
    $E \leftarrow sort(E)$\;
    $T, R \leftarrow \varnothing$\;
    \For{$e \in E$}{
      \uIf {e == insert c} {
        \For{$c' \in T$} {
          $R \leftarrow R \cup intersections(c,c')$
        }
        $T \leftarrow T \cup \left\{c\right\}$
      } \ElseIf {e == delete c} {
        $T \leftarrow T \setminus \left\{c\right\} $
      }
    }
    \Return{R}
  }
  \caption{Kwadratische aanpak (imperatief)}
  \label{algo:quadratic}
\end{algorithm}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{een cirkel $c$ met middelpunt $(x, y)$ en straal $r$}
  \KwOut{twee \textit{events} $e_1$ en $e_2$,
    corresponderend aan het toevoegen en verwijderen van $c$ aan de
    doorlooplijn, waarbij elk event ook de $y$-co\"ordinaat waarop
    het gebeurt met zich meedraagt}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{events($c$)}{
    $y_1 \leftarrow  y - r$\;
    $y_2 \leftarrow  y + r$\;
    $R \leftarrow \left\{(y_1, insert\ c), (y_2, delete\ c)\right\}$\;
    \Return{R}
  }
  \caption{Events}
  \label{algo:events}
\end{algorithm}

% \begin{figure}
%   \[
%   intersections\ cs = go\ (sort\ (events\ cs))\ [\ ]
%   \]
%   \[
%   where 
%   \]
%   \[
%   \begin{array}{l c l}
%     go\ [\ ] &= &[\ ]\\
%     go (Insert\ c\ :\ es) T &= &(map\ (circleIntersections\ c)\ T) \cup (go\ es\ T\cup\{c\})\\
%     go (Delete\ c\ :\ es) T &= &go\ es\ T\backslash\{c\}\\
%   \end{array}
%   \]
%   \label{naief_functioneel}
%   \caption{Kwadratische aanpak (functioneel)}
% \end{figure}
\subsubsection{Correctheidsbewijs}
\begin{stl} 
  Algoritme \ref{algo:quadratic} is correct en eindig.
  \label{thm:quadratic}
\end{stl}
\begin{proof}
We bewijzen eerst dat het algoritme eindigt, dan dat het correct
is. 

De eerste for-lus is eindig en levert een eindige verzameling van
events $E$ op; dit volgt rechtstreeks uit de eindigheid van de
verzameling cirkels $C$ en uit het feit dat algoritme
\ref{algo:events} altijd een eindige verzameling teruggeeft. De tweede
for-lus is genest; we bewijzen dat ook deze eindigt.

De binnenste for-lus past de binnenste lus van het na\"ieve algoritme
dat we in de vorige sectie besproken hebben toe op $T$, en is dus
gegarandeerd eindig als de verzameling $T$ bij elke iteratie eindig
is. Om dat aan te tonen, bewijzen we eerst dat de buitenste for-lus
eindig is.  Die behandelt elk element in $E$ \'e\'enmaal; het aantal
iteraties ligt dus vast op $\abs{E}$ en de lus eindigt.

Nu kunnen we aantonen dat $T$ altijd eindig is. We doen dit wederom
met een invariante.

\begin{inv}
$T$ bevat na elke iteratie van de buitenste lus maximaal $n$ elementen.
\end{inv}

\begin{proof}
Op het einde van elke iteratie van de buitenste lus wordt exact
\'e\'en cirkel ofwel toegevoegd aan ofwel verwijderd uit $T$. Elke
cirkel wordt exact \'e\'en keer toegevoegd aan of verwijderd uit $T$
(zie algoritme \ref{algo:events}). Dus $E$ bevat exact $2n$
elementen. Stel nu dat $T$ na iteratie $i$ $n + 1$ elementen zou
bevatten. Er zijn maar $n$ cirkels, dus volgens het duiventilprincipe
zou er ergens een cirkel tweemaal moeten toegevoegd zijn, wat in
strijd is met het feit dat elke cirkel exact \'e\'en keer
toegevoegd aan of verwijderd uit $T$. Dit kan niet en dus moet $T$
maximaal $n$ elementen bevatten. 
\end{proof} 

Hiermee is de eindigheid van het algoritme bewezen. Nu gaan we over
tot een correctheidsbewijs. Daarvoor volstaat het aan te tonen dat het
voldoende is om een cirkel die we toevoegen tijdens iteratie $i$ te
checken met de cirkels in $T$. We doen dit in meerdere stappen.

We merken eerst op dat we de lijst $E$ voor gebruik sorteren op
$y$-co\"ordinaat. Voor het voorbeeldgeval levert dit de volgende
geordende verzameling $E$ op: 

\[E = \left\{insert\ c_1, delete\ c_1,
insert\ c_2, insert\ c_4, insert\ c_3, delete\ c_2, delete\ c_4,
delete\ c_3 \right\}.\]

Als we nader kijken, zien we dat $E$ eigenlijk een reeks van $n$
intervallen op de $y$-as definieert die elk bepaald worden door de
uiterste $y$-co\"ordinaten van elk van de $n$ cirkels in $C$. Wanneer
we $E$ sorteren, bekomen we dan een geordende verzameling die aangeeft
wanneer deze intervallen overlappen. Dit gaan we nu formeel aantonen.

We construeren nu een verzameling $T'$ die bestaat uit alle mogelijke
combinaties van cirkels wiens intervallen overlappen, geordend volgens
toevoegpunt. Voor ons voorbeeld zou dit bijvoorbeeld de volgende
verzameling zijn:

\[T' = \left\{\left\{c_2,c_4\right\},\left\{c_2,c_4,c_3\right\},\left\{c_4,c_3\right\}\right\}\]

We willen het volgende aantonen:

\begin{lemma}
Elk element van $T'$ is een deelverzameling van een configuratie van $T$.
\label{lemma:intervals}
\end{lemma}
\begin{proof}
We tonen dit per constructie aan. Elke configuratie $t$ van $T$ is
gegenereerd door een gesorteerde sequentie van toevoegpunten en
verwijderpunten zoals we die in $E$ vinden. Elk tweetal
toevoegpunt-verwijderpunt van een cirkel vormt een interval. De
$i^{\textrm{de}}$ configuratie van $T$ wordt gegenereerd door de
eerste $i - 1$ elementen van $E$. 

Neem de $i^{de}$ configuratie van $T$. We kunnen gemakkelijk aantonen
dat die een element uit $T'$ als deelverzameling heeft. Immers, alle
cirkels die in $T$ zitten hebben overlappende intervallen door de
manier waarop $T$ gegenereerd is.

Neem anderzijds een element $t \in T'$. We tonen aan dat dit element
een deelverzameling vormt van een configuratie van $T$ gegenereerd
door $E$. Om te beginnen zijn configuraties van $T$ op dezelfde manier
geordend als elementen van $T'$, en is het dus mogelijk dat zij
elementen van $T'$ bevatten.

$T'$ bevat voor een willekeurige opstelling maximaal $2^n - n - 1$
elementen (we sluiten de lege verzameling en alle singletons uit,
gezien die triviaal deel uitmaken van minstens \'e\'en configuratie
van $T$). 
\end{proof}

\begin{gevolg}
Elke configuratie van $T$ bevat minstens \'e\'en element van $T'$ als
deelverzameling.
\label{gevolg:sweepline}
\end{gevolg}

Triviaal: immers, we hebben bij lemma \ref{lemma:intervals} aangetoond
dat elke $t \in T$ gegenereerd wordt door het toevoegen van een
overlappend interval aan een unie van overlappende intervallen of door
het verwijderen van het eerste interval in een unie van overlappende
intervallen. Dit levert terug een overlappend interval op.

Nu kunnen we bewijzen dat het algoritme correct is. In de binnenste
lus wordt een cirkel ofwel toegevoegd ofwel verwijderd uit $T$, en
voor deze twee gevallen stellen we volgende twee invarianten op:

\begin{inv}
Elke cirkel die v\'o\'or het begin van iteratie $i$ uit $T$ verwijderd is
kan onmogelijk snijden met een cirkel die toegevoegd wordt tijdens
iteratie $i$.
\label{inv:t1}
\end{inv}

\begin{proof}
We bewijzen uit het ongerijmde. Stel dat er een cirkel $c' \in C$
bestaat die uit $T$ verwijderd is maar die wel met $c$ snijdt. Na het
nakijken op snijpunten wordt $c$ toegevoegd aan $T$. Gezien $c$ en
$c'$ snijden, overlapt het interval op de $y$-as dat correspondeert
aan $c'$ met het interval dat correspondeert aan $c$.

Nu heeft $c'$ al eens in $T$ gezeten: uit gevolg 1
\ref{gevolg:sweepline} volgt dan dat onze stelling een contradictie is;
immers, dan is er een element $t \in T'$ waarin zowel $c$ als $c'$
zitten, maar dit behoort dan tot geen enkele configuratie van $T$,
gezien een cirkel die verwijderd is niet meer toegevoegd kan worden
aan $T$. Daarmee is de invariante bewezen.
\end{proof}

\begin{gevolg} 
Een cirkel die aan $T$ wordt toegevoegd aan het einde van iteratie $i$
kan tijdens die iteratie enkel snijpunten van zichzelf met de cirkels
uit $T$ toevoegen aan de verzameling snijpunten.
\end{gevolg} 

Het bewijs dat de snijpunten van alle cirkels op deze manier in de
uiteindelijke verzameling snijpunten komen te zitten loopt analoog aan
dat van algoritme \ref{algo:naive}. Daarmee is ons correctheidsbewijs afgerond.
\end{proof}
\subsubsection{Complexiteit}

\input{illustraties/voorbeeld_2}

\subsection{Linearitmisch}
\label{sec:linearitmisch}

\subsubsection{Algoritme}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{een cirkel $c$ met middelpunt $(x, y)$ en straal $r$}
  \KwOut{een interval $I$ corresponderend aan het interval tussen de uiterste $x$-co\"ordinaten van $c$}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{interval($c$)}{
    $x_1 \leftarrow x - r$\;
    $x_2 \leftarrow x + r$\;
    $I \leftarrow [x_1, x_2]$\;
    \Return{I}
  }
  \caption{Breedte-interval van een cirkel}
\end{algorithm}
\label{algo:interval}

\begin{algorithm}[H]
  \KwIn{een lijst van $n$ cirkels $C$, gegeven door hun middelpunt en straal}
  \KwOut{een verzameling van $S$ snijpunten $R$ van de cirkels in $C$}
  \SetAlgoLined
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersections3($C$)}{
    $E \leftarrow \varnothing$\;
    \For{$c \in C$}{
      $E \leftarrow E \cup events(c)$;
    }
    $E \leftarrow sort(E)$\;
    $T, R \leftarrow \varnothing$\;
    \For{$e \in E$}{
      \uIf {e == insert c} {
        \For{$c' \in T$} {
          \If {$interval(c) \cap interval(c') \neq \varnothing$} {
            $R \leftarrow R \cup intersections(c,c')$
          }
        }
        $T \leftarrow T \cup \left\{c\right\}$
      } \ElseIf {e == delete c} {
        $T \leftarrow T \setminus \left\{c\right\} $
      }
    }
    \Return{R}
  }
  \label{algo:linearithmic}
  \caption{Linearitmische aanpak (imperatief)}
\end{algorithm}
\subsubsection{Correctheidsbewijs}
\begin{stl} Algoritme \ref{algo:linearithmic} is correct en eindig.\end{stl}
\begin{proof}
Dit algoritme verschilt van algoritme \ref{algo:quadratic} op slechts
één punt: in de binnenste for-lus wordt nog een extra check gedaan op
het overlappen van de intervallen van de cirkels op de $x$-as. We
voegen geen extra lussen toe, dus de eindigheid van het algoritme is
gegarandeerd bij krachte van stelling \ref{thm:quadratic}.

Door de check in de binnenste for-lus wordt nog slechts een
deelverzameling van $T$ vergeleken met de cirkel $c$ toegevoegd in
iteratie $i$ van de tweede for-lus. Noem deze deelverzameling $B$. Het
volstaat aan te tonen dat er in $T \setminus B$ geen enkele cirkel zit die zou
kunnen snijden met $c$. Dat is simpel: het criterium dat we opleggen
is dat $c$ over de $x$-as moet overlappen met elke $c'$; formeel zien
we in dat 

\[B = \left\{c' | c' \in T, interval(c) \cap interval(c') \neq \varnothing \right\} \]

en dus is het ook zo dat

\[T \setminus B = \left\{c' | c' \in T, interval(c) \cap interval(c') = \varnothing \right\} \]

Het is niet moeilijk in te zien dat geen enkele cirkel $c'$ in $T
\setminus B$ kan snijden met de nieuw toegevoegde cirkel $c$: gezien
ze niet overlappen op de $x$-as, is de horizontale afstand tussen hen
groter is dan de som van hun stralen, wat uitsluit dat ze
snijden. Algoritme \ref{algo:linearithmic} is dus ook correct.
\end{proof}

\subsubsection{Complexiteit}

\input{illustraties/voorbeeld_3}