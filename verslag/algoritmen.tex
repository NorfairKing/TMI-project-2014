\section{Algoritmen}

\input{illustraties/voorbeeld_opgave}

\subsection{Snijpunt van twee cirkels berekenen}
\label{sec:snijpunt}

\subsubsection{Algoritme}
\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{twee cirkels, $c$ en $c'$ met resp middelpunten $p_{1}, p_{2}$ en stralen $r_{1}, r_{2}$}
  \KwOut{waar als en slechts als de twee cirkels snijden}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersect($c$,$c'$)}{
    d $\leftarrow \lVert p_2 - p_1\rVert $\\
    \eIf{($d \leq r_1 + r_2) \land (d \geq abs (r_1 - r_2))$}{
      \Return{true}
    }{
      \Return{false}
    }
  }

  \caption{Nagaan of twee cirkels snijden}
\end{algorithm}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{twee cirkels, $c$ en $c'$ met resp. middelpunten $p_{1} = (x_1,y_1), p_{2} = (x_2,y_2)$ en stralen $r_{1}, r_{2}$}
  \KwOut{geen, of twee snijpunten van de twee cirkels (die dan identiek zijn)}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersections($c$,$c'$)}{
    \eIf{$intersect(c, c') \land c1 \neq c2$}{
      $d \leftarrow \lVert p_2 - p_1\rVert $ \\
      $\alpha \leftarrow \frac{r_1^2 -r_2^2}{2d^2}$\\
      $s \leftarrow \frac{x_1+x_2}{2} + \alpha(x_2-x_1)$\\
      $t \leftarrow \frac{y_1+y_2}{2} + \alpha(y_2-y_1)$\\

      $\delta \leftarrow \frac{1}{4}  \sqrt { (d+r_1+r_2)(d+r_1-r_2)(d-r_1+r_2)(r_1+r_2-d)}$\\
      $x_1' \leftarrow s + 2\delta\frac{y_1-y_2}{d^2}$\\
      $x_2' \leftarrow s - 2\delta\frac{y_1-y_2}{d^2}$\\
      $y_1' \leftarrow t - 2\delta\frac{x_1-x_2}{d^2}$\\
      $y_2' \leftarrow t + 2\delta\frac{x_1-x_2}{d^2}$\\
      \Return{$\left\{(x_1',y_1'),(x_2',y_2')\right\}$}
    }{
      \Return{$\varnothing$}
    }
  }
  \caption{Snijpunten van twee cirkels berekenen}
\end{algorithm}

\subsubsection{Theoretische Achtergrond}
\todo{aannames}
\begin{figure}[H]
\input{illustraties/snijpunten_theorie}
\end{figure}
Gegeven twee cirkels $C_1$ en $C_2$ zoeken we $C_1 \cap C_2$. Noem $r_i$ de straal van $C_i$. We gaan er ook van uit dat $r$ steeds positief is. Het is niet nodig om deze voorwaarde te stellen op theoretisch niveau, maar alle theorie is nog steeds geldig wanneer we enkel over positieve $r$ spreken.
\paragraph{Mogelijke doorsneden}
Twee cirkels kunnen op vier specifieke manieren gelegen zijn, met betrekking tot hun doorsnede. Het blijkt zo te zijn dat we de situatie kunnen herkennen aan de waarde van $d=\Vert M_2-M_1\Vert$ wanneer de cirkels niet samenvallen.
\begin{itemize}
\item De cirkels vallen samen.\\
\[C_1 \cap C_2 = C_1 = C_2\]
Dit valt voor wanneer de cirkels concentrisch zijn en een even grote straal hebben.
\[
M_1 = M_2 \text{ en } r_1 = r_2
\]
Hier geldt $d = 0$, maar deze situatie zullen we in het programma negeren.

\item De cirkels snijden in precies twee punten.\\
\[C_1 \cap C_1 = \{P_1,P_2\} \text{ met } P_1,P_2 \in \mathbb{R}^2\]
In deze situatie geldt zowel $d < r_1+r_2$ als $ d > |r_1-r_2|$\todo{nakijken}.

\item De cirkels raken aan elkaar.\\
\[C_1 \cap C_2 = \{P\}\]
In deze situatie geldt $d = r_1+r_2$.

\item De cirkels raken niet.
\[C_1 \cap C_2 = \{P_1,P_2\} \text{ met } P_1,P_2 \in \mathbb{C}^2\]
Hier geldt ofwel $d < |r_1-r_2|$ ofwel $d > r_1+r_2$
\end{itemize}

\paragraph{Benaming}
\todo{zie de figuur}
We geven de twee stralen standaard de benaming $r_1$ en $r_2$ respectievelijk.
Noem de middelpunten van de cirkels $M_1(x_1,y_1)$ en $M_2(x_2,y_2)$. 

Noem de doorsnede van $C_1$ en $C_2$ $I$. Wanneer de twee cirkels gelijk zijn geldt $C_1 = C_2 = I$.
In de rest van dit deel bespreken we enkel het geval waarbij de snijpunt(en) re\"eel zijn.
Noem de snijpunten $P_1$ en $P_2$ in de berekening.
Wanneer er maar \'e\'en snijpunt is zal de berekening nog steeds gelden, maar zal $P_1$ gelijk zijn aan $P_2$.

Noem de rechte door $M_1$ en $M_2$ $l_1$ en de rechte door $P_1$ en $P_2$ $l_2$.
Het snijpunt van $l_1$ en $l_2$ noemen we $P_0$.
Noem $a$ de afstand van $P_1$ tot $P_0$ en $b$ de afstand van $P_2$ tot $P_0$.
Noem $d$ de afstand tussen $M_1$ en $M_2$.
\[
d = a + b
\]
.\todo{herschrijven, beter uitleggen}
Noem $h$ de afstand van $P_1$ (of $P_2$) tot $P_0$.

\paragraph{Snijpunten berekenen}
We zien dat de driehoeken $M_1P_1P_0$, $M_2P_1P_0$, $M_1P_2P_0$ en $M_2P_2P_0$ rechthoekige driehoeken zijn. We gebruiken nu de regel van Pythagoras om de volgende gelijkheden te bekomen.
\[
\left\{
\begin{array}{c l r}
r_1^2 = a^2 + h^2 & (1)\\
r_2^2 = b^2 + h^2 & (2)
\end{array}
\right.
\]
Uit de eerste vergelijking kunnen we een uitdrukking voor $h$ halen.
\[
h = \sqrt{r_{1}^{2}-a^{2}}
\]
Trekken we vergelijking $(2)$ van vergelijking $(1)$ af, dan krijgen we volgende vergelijking.
\[
\begin{array}{r l}
r_1^2 -r_1^2 & = a^2 - b^2\\
& = (a-b)(a+b)\\
& = d(a-b)\\
& = d(a-d+a)\\
r_1^2 -r_1^2 & = d(2a-d)
\end{array}
\]
Vormen we deze vergelijking om om een uitdrukking voor $a$ te bekomen, dan krijgen we volgende uitdrukking.
\[
a = \frac{r_1^2-r_2^2 + d^2}{2d}
\]
Noem de richtingscoeffici\"ent van $l_1$ $m$ en de richtingsco\"efficient van $l_2$ $n$.
We kunnen $m$ berekenen uit de co\"ordinaten van $M_1$ en $M_2$.
\[
m = \frac{y_2-y_1}{x_2-x_1}
\]
Omdat $l_1$ loodrecht staat op $l_2$ weten we dat de richtingsco\"efficient $n$ van $l_2$ het omgekeerd tegengestelde is van de richtingsco\"efficient van $l_1$.
\[
n = -\frac{1}{m} = \frac{x_1-x_2}{y_1-y_2}
\]
Vervolgens kunnen we de co\"ordinaten van $P_0$ berekenen.
\[
P_0 = M_1 + a(M_2-M_1) = M_2 + b(M_1-M_2)
\]
\todo{2e gelijkheid nakijken}
\[
\begin{bmatrix}
P_{0x}\\P_{0y}\\
\end{bmatrix}
=
\begin{bmatrix}
M_{1x} + a(M_{2x}-M_{1x})\\
M_{1y} + a(M_{2y}-M_{1y})\\
\end{bmatrix}
=
\begin{bmatrix}
M_{2x} + b(M_{1x}-M_{2x})\\
M_{2y} + b(M_{1y}-M_{2y})\\
\end{bmatrix}
\]
Tenslotte kunnen we de co\"ordinaten van de snijpunten berekenen uit de co\"ordinaten van $M_1$, $M_2$ en $P_0$.
\todo{meer uitleg hier, dit is niet vanzelfsprekend}
\[
\left\{
\begin{array}{c l}
P_x &= x_0 \pm \frac{h}{d}(y_2-y_1)\\
P_y &= y_0 \mp \frac{h}{d}(x_2-x_1)
\end{array}
\right.
\]

\subsubsection{Complexiteit}
De snijpunten berekenen van twee \emph{verschillende} cirkels heeft een constante uitvoeringstijd. Het is opmerkelijk dat er in, nog steeds constante, kortere tijd kan nagekeken worden of twee cirkels snijden, v\'o\'or de snijpunten berekend worden, zodat er minder berekeningen gedaan kunnen worden.\todo{vermelden wat er gebeurd als niet-snijdende cirkels in het algoritme terecht komen}


\subsection{Na\"ief}
\label{sec:naief}

\subsubsection{Algoritme}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{een lijst van $n$ cirkels $C$, gegeven door hun middelpunt en straal}
  \KwOut{een verzameling van $S$ snijpunten $R$ van de cirkels in $C$}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersections1($C$)}{
    R $\leftarrow \varnothing$\;
    \For{$i\leftarrow 1$ \KwTo $n$}{
      \For{$j\leftarrow i$ \KwTo $n$}{
        $R \leftarrow R \cup intersections(C(i),C(j))$
      }

    }
    \Return{R}
  }
  \caption{Na\"ieve aanpak (imperatief)}
  \label{algo:naive}
\end{algorithm}

\subsubsection{Correctheidsbewijs}
\begin{stl} Algoritme \ref{algo:naive} is correct en eindig.\end{stl}
\begin{proof}
Het algoritme eindigt: immers, de instructie in de binnenste for-lus
wordt exact \[\sum_{i=1}^{n} \sum_{j<i}^{n} 1 = \frac{n(n-1)}{2} \]
keer uitgevoerd. 

De correctheid van het algoritme bewijzen we met een lusinvariante:
\begin{inv} 
Na de $i^{\textrm{de}}$ iteratie van de buitenste lus zijn
alle snijpunten van de eerste $i$ cirkels met de andere cirkels
toegevoegd aan de verzameling snijpunten.
\end{inv} 

We bewijzen dit per inductie.

\textit{Basisstap.} Het is duidelijk dat voor $i = 1$ de invariante
geldt. Immers, na iteratie 1 hebben we cirkel 1 in de lijst nagekeken
op snijpunten met alle $n-1$ andere cirkels, en zijn dus alle
snijpunten van de eerste $i$ cirkels met alle andere cirkels
toegevoegd aan de verzameling snijpunten.

\textit{Inductiestap.} Stel dat voor de eerste $i - 1$ iteraties de
invariante geldt. We tonen aan dat na de $i^{\textrm{de}}$
iteratie de invariante nog geldt. In de $i^{\textrm{de}}$ iteratie
wordt cirkel $i$ nagekeken op snijpunten met alle cirkels die later in
de lijst komen. De snijpunten van $i$ met alle cirkels die later in de
lijst komen zullen dus zeker in de verzameling snijpunten zitten na
afloop van deze iteratie. 

Maar ook alle snijpunten met de cirkels die vroeger in de lijst zitten
hebben we al gevonden en bijgehouden; immers, in \'e\'en van de vorige
iteraties is het snijpunt van elk van die cirkels met cirkel $i$ al
berekend en toegevoegd aan de verzameling snijpunten. Bij krachte van
het inductieprincipe bevat de verzameling snijpunten na iteratie $i$
dus alle snijpunten van de eerste $i$ cirkels met alle andere
cirkels. Na iteratie $n$ zijn dus alle snijpunten gevonden; het
algoritme is correct.
\end{proof}

\subsubsection{Complexiteit}
De na\"ieve aanpak heeft complexiteit $O(n^2)$. Dit volgt rechtstreeks uit ons bewijs van eindigheid.

% \begin{figure}
%   \[
%   intersections\ cs\ = \{\ circleIntersections\ c1\ c2\ |\ c1 \leftarrow\ cs,\ c2\ \leftarrow\\ cs \}
%   \]
%   \label{naief_functioneel}
%   \caption{Na\"ieve aanpak (functioneel)}
% \end{figure}

\input{illustraties/voorbeeld_1}

\subsection{Kwadratisch}
\label{sec:kwadratisch}

\subsubsection{Algoritme}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{een lijst van $n$ cirkels $C$, gegeven door hun middelpunt en straal}
  \KwOut{een verzameling van $S$ snijpunten $R$ van de cirkels in $C$}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersections2($C$)}{
    $E \leftarrow \varnothing$\;
    \For{$c \in C$}{
      $E \leftarrow E \cup events(c)$;
    }
    $E \leftarrow sort(E)$\;
    $T, R \leftarrow \varnothing$\;
    \For{$e \in E$}{
      \uIf {e == insert c} {
        \For{$c' \in T$} {
          $R \leftarrow R \cup intersections(c,c')$
        }
        $T \leftarrow T \cup \left\{c\right\}$
      } \ElseIf {e == delete c} {
        $T \leftarrow T \setminus \left\{c\right\} $
      }
    }
    \Return{R}
  }
  \caption{Kwadratische aanpak (imperatief)}
  \label{algo:quadratic}
\end{algorithm}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{een cirkel $c$ met middelpunt $(x, y)$ en straal $r$}
  \KwOut{twee \textit{events} $e_1$ en $e_2$,
    corresponderend aan het toevoegen en verwijderen van $c$ aan de
    doorlooplijn, waarbij elk event ook de $y$-co\"ordinaat waarop
    het gebeurt met zich meedraagt}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{events($c$)}{
    $y_1 \leftarrow  y - r$\;
    $y_2 \leftarrow  y + r$\;
    $R \leftarrow \left\{(y_1, insert\ c), (y_2, delete\ c)\right\}$\;
    \Return{R}
  }
  \caption{Events}
  \label{algo:events}
\end{algorithm}

% \begin{figure}
%   \[
%   intersections\ cs = go\ (sort\ (events\ cs))\ [\ ]
%   \]
%   \[
%   where 
%   \]
%   \[
%   \begin{array}{l c l}
%     go\ [\ ] &= &[\ ]\\
%     go (Insert\ c\ :\ es) T &= &(map\ (circleIntersections\ c)\ T) \cup (go\ es\ T\cup\{c\})\\
%     go (Delete\ c\ :\ es) T &= &go\ es\ T\backslash\{c\}\\
%   \end{array}
%   \]
%   \label{naief_functioneel}
%   \caption{Kwadratische aanpak (functioneel)}
% \end{figure}
\subsubsection{Correctheidsbewijs}
\begin{stl} Algoritme \ref{algo:quadratic} is correct en eindig.\end{stl}
\begin{proof}
We bewijzen eerst dat het algoritme eindigt, dan dat het correct
is. 

De eerste for-lus is eindig en levert een eindige verzameling van
events $E$ op; dit volgt rechtstreeks uit de eindigheid van de
verzameling cirkels $C$ en uit het feit dat algoritme
\ref{algo:events} altijd een eindige verzameling teruggeeft. De tweede
for-lus is genest; we bewijzen dat ook deze eindigt.

De binnenste for-lus past de binnenste lus van het na\"ieve algoritme
dat we in de vorige sectie besproken hebben toe op $T$, en is dus
gegarandeerd eindig als de verzameling $T$ bij elke iteratie eindig
is. Om dat aan te tonen, bewijzen we eerst dat de buitenste for-lus
eindig is.  Die behandelt elk element in $E$ \'e\'enmaal; het aantal
iteraties ligt dus vast op $\abs{E}$ en de lus eindigt.

Nu kunnen we aantonen dat $T$ altijd eindig is. We doen dit wederom
met een invariante.

\begin{inv}
$T$ bevat na elke iteratie van de buitenste lus maximaal $n$ elementen.
\end{inv}

Op het einde van elke iteratie van de buitenste lus wordt exact
\'e\'en cirkel ofwel toegevoegd aan ofwel verwijderd uit $T$. Elke
cirkel wordt exact \'e\'en keer toegevoegd aan of verwijderd uit $T$
(zie algoritme \ref{algo:events}). Dus $E$ bevat exact $2n$
elementen. Stel nu dat $T$ na iteratie $i$ $n + 1$ elementen zou
bevatten. Er zijn maar $n$ cirkels, dus volgens het duiventilprincipe
zou er ergens een cirkel tweemaal moeten toegevoegd zijn, wat in
strijd is met het feit dat elke cirkel exact \'e\'en keer
toegevoegd aan of verwijderd uit $T$. Dit kan niet en dus moet $T$
maximaal $n$ elementen bevatten. Hiermee is de eindigheid van het
algoritme bewezen.

Nu gaan we over tot een correctheidsbewijs. Daarvoor volstaat het aan
te tonen dat het voldoende is om een cirkel die we toevoegen tijdens
iteratie $i$ te checken met de cirkels in $T$. We doen dit in meerdere stappen.

We merken eerst op dat we de lijst $E$ voor gebruik sorteren op
$y$-co\"ordinaat. Voor het voorbeeldgeval levert dit de volgende
geordende verzameling $E$ op: \[E = \left\{insert\ c_1, delete\ c_1,
insert\ c_2, insert\ c_4, insert\ c_3, delete\ c_2, delete\ c_4,
delete\ c_3 \right\}.\]

Als we nader kijken, zien we dat $E$ eigenlijk een reeks van $n$
intervallen op de $y$-as definieert die elk bepaald worden door de
uiterste $y$-co\"ordinaten van elk van de $n$ cirkels in $C$. Wanneer
we $E$ sorteren, bekomen we dan een geordende verzameling die aangeeft
wanneer deze intervallen overlappen.

Nu kunnen we bewijzen dat het algoritme correct is. In de binnenste
lus wordt een cirkel ofwel toegevoegd ofwel verwijderd uit $T$, en
voor deze twee gevallen stellen we volgende twee invarianten op:

\begin{inv}
Elke cirkel die niet in $T$ zit v\'o\'or iteratie $i$ kan onmogelijk
snijden met een cirkel die toegevoegd wordt tijdens iteratie $i$.
\label{inv:t1}
\end{inv}

We bewijzen uit het ongerijmde. Stel dat er een cirkel $c' \in C$
bestaat die niet in $T$ zit maar die wel met $c$ snijdt. Dan wil dit
zeggen dat het interval op de $y$-as dat correspondeert aan $c'$ niet
overlapt met het interval dat correspondeert aan $c$. Dit is echter
onmogelijk: als dit het geval zou zijn, zou de verticale afstand
tussen de middelpunten van $c$ en $c'$ groter zijn dan de som van de
stralen van beide cirkels, en dan is het onmogelijk dat ze snijden.

\begin{inv}
Elke cirkel die uit $T$ verwijderd wordt tijdens iteratie $i$ kan onmogelijk
snijden met een cirkel die toegevoegd wordt tijdens iteratie $j > i$.
\label{inv:t2}
\end{inv}

We bewijzen uit het ongerijmde. Stel dat we tijdens iteratie $i$ een
cirkel $c'$ verwijderen uit $T$ die toch snijdt met een cirkel $c$ die
pas in een latere iteratie $j$ toegevoegd wordt. De intervallen
corresponderend aan beide cirkels moeten overlappen (zoals aangetoond
in het bewijs van invariante \ref{inv:t1}). We hebben echter
aangetoond dat elke unie van overlappende intervallen vervat is in een
configuratie van $T$; er moet dus een configuratie van $T$ zijn waarin
zowel $c$ als $c'$ zitten, wat in tegenspraak is met de stelling.

Uit deze twee invarianten volgt dat een cirkel toegevoegd tijdens
iteratie enkel en alleen kan snijden met een cirkel die op dat moment
al in $T$ zit. Het is dus voldoende om die cirkel te vergelijken met
de cirkels in $T$. Daarmee is ons correctheidsbewijs afgerond.
\end{proof}
\subsubsection{Complexiteit}

\input{illustraties/voorbeeld_2}

\subsection{Linearitmisch}
\label{sec:linearitmisch}

\subsubsection{Algoritme}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwIn{een cirkel $c$ met middelpunt $(x, y)$ en straal $r$}
  \KwOut{een interval $I$ corresponderend aan het interval tussen de uiterste $x$-co\"ordinaten van $c$}
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{interval($c$)}{
    $x_1 \leftarrow x - r$\;
    $x_2 \leftarrow x + r$\;
    $I \leftarrow [x_1, x_2]$\;
    \Return{I}
  }
  \caption{Breedte-interval van een cirkel}
\end{algorithm}
\label{algo:interval}

\begin{algorithm}[H]
  \KwIn{een lijst van $n$ cirkels $C$, gegeven door hun middelpunt en straal}
  \KwOut{een verzameling van $S$ snijpunten $R$ van de cirkels in $C$}
  \SetAlgoLined
  \SetKwProg{Fn}{Procedure}{:}{end}
  \Fn{intersections3($C$)}{
    $E \leftarrow \varnothing$\;
    \For{$c \in C$}{
      $E \leftarrow E \cup events(c)$;
    }
    $E \leftarrow sort(E)$\;
    $T, R \leftarrow \varnothing$\;
    \For{$e \in E$}{
      \uIf {e == insert c} {
        \For{$c' \in T$} {
          \If {$interval(c) \cap interval(c') \neq \varnothing$} {
            $R \leftarrow R \cup intersections(c,c')$
          }
        }
        $T \leftarrow T \cup \left\{c\right\}$
      } \ElseIf {e == delete c} {
        $T \leftarrow T \setminus \left\{c\right\} $
      }
    }
    \Return{R}
  }
  \caption{Linearitmische aanpak (imperatief)}
\end{algorithm}
\subsubsection{Correctheidsbewijs}
\subsubsection{Complexiteit}

\input{illustraties/voorbeeld_3}