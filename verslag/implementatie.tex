\section{Implementatie}
\label{sec:implementation}
\todo{vermelden: check uitgezet}
In deze sectie beschrijven we de implementatiedetails van de algoritmes en de gebruikte gegevensstructuren.
\todo{vermeld de problemen met haskell}

\subsection{Haskell}
We hebben de code geschreven in Haskell. Haskell is een luie, pure,  functionele taal. Dit vereenvoudigde het implementeren van de wiskundige aspecten van dit project en verkortte de code in het geheel.

Haskell zorgde evenwel voor een aantal problemen.

\subsubsection{Timing}
De volgorde waarin code wordt uitgevoerd wordt niet gegarandeerd in Haskell.
Code wordt doorgaans enkel ge\"evalueerd wanneer het resultaat nodig is voor uitvoer.
Een resultaat dat nooit opgevraagd wordt zal dus ook nooit berekend worden.
Dit heeft als gevolg dat het algoritme normaal gezien al aan de uitvoer begint tijdens de invoer.
Op deze manier valt het algoritme echter niet te timen.

We hebben het algoritme zo ge\"implementeerd dat de cirkels eerst worden ingelezen, de snijpunten dan worden berekend en pas daarna de snijpunten worden uitgelezen. Enkel het berekenen van de snijpunten wordt dan getimet.



\subsubsection{Evaluatie}
\todo{strictness hacking}

\subsection{Naief}
Het naieve algoritme maakt gebruik van staartrecursie zodat er nooit twee cirkels maar dan \'e\'en keer met elkaar vergeleken worden.

\subsection{Kwadratisch}
Het kwadratische algoritme maakt geen gebruik van externe datastructuren. Het gebruikt de ingebouwde lijsten van haskell om de status bij te houden.


\subsection{Linearitmisch}
het Linearitmische algoritme maakt gebruikt van een datastructuur genaamd `intervalmap' om de status bij te houden.
Op deze manier kunnen de cirkels met overlappende intervallen kunnen gezocht worden in $O(R\log N)$ tijd (waarbij $R$ het aantal cirkels met overlappende intervallen voorstelt).